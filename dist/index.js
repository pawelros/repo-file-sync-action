import{createRequire as __WEBPACK_EXTERNAL_createRequire}from"module";var __webpack_modules__={159:module=>{module.exports=eval("require")("@actions/core")},211:module=>{module.exports=eval("require")("@actions/github")},620:module=>{module.exports=eval("require")("@actions/github/lib/utils.js")},375:module=>{module.exports=eval("require")("@octokit/plugin-throttling")},269:module=>{module.exports=eval("require")("@putout/git-status-porcelain")},702:module=>{module.exports=eval("require")("action-input-parser")},203:module=>{module.exports=eval("require")("fs-extra")},991:module=>{module.exports=eval("require")("js-yaml")},796:module=>{module.exports=eval("require")("node-readfiles")},907:module=>{module.exports=eval("require")("nunjucks")}};var __webpack_module_cache__={};function __nccwpck_require__(e){var t=__webpack_module_cache__[e];if(t!==undefined){return t.exports}var i=__webpack_module_cache__[e]={exports:{}};var r=true;try{__webpack_modules__[e](i,i.exports,__nccwpck_require__);r=false}finally{if(r)delete __webpack_module_cache__[e]}return i.exports}if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=new URL(".",import.meta.url).pathname.slice(import.meta.url.match(/^file:\/\/\/\w:/)?1:0,-1)+"/";var __webpack_exports__={};(()=>{var e=__nccwpck_require__(159);const t=__WEBPACK_EXTERNAL_createRequire(import.meta.url)("fs");var i=__nccwpck_require__(269);var r=__nccwpck_require__(211);var s=__nccwpck_require__(620);var a=__nccwpck_require__(375);const n=__WEBPACK_EXTERNAL_createRequire(import.meta.url)("path");var o=__nccwpck_require__(991);var u=__nccwpck_require__(203);var c=__nccwpck_require__(702);const l=true;const d=false;const h=false;let p;try{let t=false;let i=(0,c.getInput)({key:"GH_PAT"});if(!i){i=(0,c.getInput)({key:"GH_INSTALLATION_TOKEN"});t=true;if(!i){e.setFailed("You must provide either GH_PAT or GH_INSTALLATION_TOKEN");process.exit(1)}}p={GITHUB_TOKEN:i,GITHUB_SERVER_URL:process.env.GITHUB_SERVER_URL||"https://github.com",IS_INSTALLATION_TOKEN:t,GIT_EMAIL:(0,c.getInput)({key:"GIT_EMAIL"}),GIT_USERNAME:(0,c.getInput)({key:"GIT_USERNAME"}),CONFIG_PATH:(0,c.getInput)({key:"CONFIG_PATH",default:".github/sync.yml"}),IS_FINE_GRAINED:(0,c.getInput)({key:"IS_FINE_GRAINED",default:false}),COMMIT_BODY:(0,c.getInput)({key:"COMMIT_BODY",default:""}),COMMIT_PREFIX:(0,c.getInput)({key:"COMMIT_PREFIX",default:"🔄"}),COMMIT_EACH_FILE:(0,c.getInput)({key:"COMMIT_EACH_FILE",type:"boolean",default:true}),PR_LABELS:(0,c.getInput)({key:"PR_LABELS",default:["sync"],type:"array",disableable:true}),PR_BODY:(0,c.getInput)({key:"PR_BODY",default:""}),ASSIGNEES:(0,c.getInput)({key:"ASSIGNEES",type:"array"}),REVIEWERS:(0,c.getInput)({key:"REVIEWERS",type:"array"}),TEAM_REVIEWERS:(0,c.getInput)({key:"TEAM_REVIEWERS",type:"array"}),TMP_DIR:(0,c.getInput)({key:"TMP_DIR",default:`tmp-${Date.now().toString()}`}),DRY_RUN:(0,c.getInput)({key:"DRY_RUN",type:"boolean",default:false}),SKIP_CLEANUP:(0,c.getInput)({key:"SKIP_CLEANUP",type:"boolean",default:false}),OVERWRITE_EXISTING_PR:(0,c.getInput)({key:"OVERWRITE_EXISTING_PR",type:"boolean",default:true}),GITHUB_REPOSITORY:(0,c.getInput)({key:"GITHUB_REPOSITORY",required:true}),SKIP_PR:(0,c.getInput)({key:"SKIP_PR",type:"boolean",default:false}),ORIGINAL_MESSAGE:(0,c.getInput)({key:"ORIGINAL_MESSAGE",type:"boolean",default:false}),COMMIT_AS_PR_TITLE:(0,c.getInput)({key:"COMMIT_AS_PR_TITLE",type:"boolean",default:false}),BRANCH_PREFIX:(0,c.getInput)({key:"BRANCH_PREFIX",default:"repo-sync/SOURCE_REPO_NAME"}),FORK:(0,c.getInput)({key:"FORK",default:false,disableable:true})};e.setSecret(p.GITHUB_TOKEN);e.debug(JSON.stringify(p,null,2));while(u.existsSync(p.TMP_DIR)){p.TMP_DIR=`tmp-${Date.now().toString()}`;e.warning(`TEMP_DIR already exists. Using "${p.TMP_DIR}" now.`)}}catch(t){e.setFailed(t.message);process.exit(1)}const parseRepoName=t=>{let i=new URL(p.GITHUB_SERVER_URL).host;if(t.startsWith("http")){const r=new URL(t);i=r.host;t=r.pathname.replace(/^\/+/,"");e.info("Using custom host")}const r=t.split("/")[0];const s=t.split("/")[1].split("@")[0];const a=t.split("@")[1]||"default";return{fullName:`${i}/${r}/${s}`,uniqueName:`${i}/${r}/${s}@${a}`,host:i,user:r,name:s,branch:a}};const parseExclude=(e,t)=>{if(e===undefined||typeof e!=="string")return undefined;const i=e.split("\n").filter((e=>e));return i.map((e=>n.join(t,e)))};const parseFiles=t=>t.map((t=>{if(typeof t==="string")t={source:t};if(t.source!==undefined){return{source:t.source,dest:t.dest||t.source,template:t.template===undefined?d:t.template,replace:t.replace===undefined?l:t.replace,deleteOrphaned:t.deleteOrphaned===undefined?h:t.deleteOrphaned,exclude:parseExclude(t.exclude,t.source)}}e.warning("Warn: No source files specified")}));async function parseConfig(){const e=await u.promises.readFile(p.CONFIG_PATH);const t=o.load(e.toString());const i={};Object.keys(t).forEach((e=>{if(e==="group"){const r=t[e];const s=Array.isArray(r)?r:[r];s.forEach((e=>{const t=typeof e.repos==="string"?e.repos.split("\n").map((e=>e.trim())).filter((e=>e)):e.repos;t.forEach((t=>{const r=parseFiles(e.files);const s=parseRepoName(t);if(i[s.uniqueName]!==undefined){i[s.uniqueName].files.push(...r);return}i[s.uniqueName]={repo:s,files:r}}))}))}else{const r=parseFiles(t[e]);const s=parseRepoName(e);if(i[s.uniqueName]!==undefined){i[s.uniqueName].files.push(...r);return}i[s.uniqueName]={repo:s,files:r}}}));return Object.values(i)}const g=p;var m=__nccwpck_require__(796);const f=__WEBPACK_EXTERNAL_createRequire(import.meta.url)("child_process");var _=__nccwpck_require__(907);_.configure({autoescape:true,trimBlocks:true,lstripBlocks:true});async function forEach(e,t){for(let i=0;i<e.length;i++){await t(e[i],i,e)}}function dedent(e,...t){const i=[];const r=typeof e==="string"?[e]:e.slice();r[r.length-1]=r[r.length-1].replace(/\r?\n([\t ]*)$/,"");for(let e=0;e<r.length;e++){let t;if(t=r[e].match(/\n[\t ]+/g)){i.push(...t)}}if(i.length){const e=Math.min(...i.map((e=>e.length-1)));const t=new RegExp(`\n[\t ]{${e}}`,"g");for(let e=0;e<r.length;e++){r[e]=r[e].replace(t,"\n")}}r[0]=r[0].replace(/^\r?\n/,"");let s=r[0];for(let e=0;e<t.length;e++){s+=t[e]+r[e+1]}return s}function execCmd(t,i,r=true){e.debug(`EXEC: "${t}" IN ${i}`);return new Promise(((e,s)=>{(0,f.exec)(t,{cwd:i,maxBuffer:1024*1024*4},(function(t,i){t?s(t):e(r?i.trim():i)}))}))}function addTrailingSlash(e){return e.endsWith("/")?e:e+"/"}async function pathIsDirectory(e){const t=await u.lstat(e);return t.isDirectory()}async function write(e,t,i){if(typeof i!=="object"){i={}}const r=_.render(e,i);await u.outputFile(t,r)}async function copy(t,i,r,s){const a=r&&s.deleteOrphaned;const o=s.exclude;const filterFunc=t=>{if(o!==undefined){let i="";if(t.endsWith("/")){i=t}else{i=t.split("/").slice(0,-1).join("/")+"/"}if(o.includes(i)){e.debug(`Excluding file ${t} since its path is included as one of the excluded paths.`);return false}if(o.includes(t)){e.debug(`Excluding file ${t} since it is explicitly added in the exclusion list.`);return false}}return true};if(s.template){if(r){e.debug(`Render all files in directory ${t} to ${i}`);const r=await m(t,{readContents:false,hidden:true});for(const e of r){if(!filterFunc(e)){continue}const r=n.join(t,e);const a=n.join(i,e);await write(r,a,s.template)}}else{e.debug(`Render file ${t} to ${i}`);await write(t,i,s.template)}}else{e.debug(`Copy ${t} to ${i}`);await u.copy(t,i,s.exclude!==undefined&&{filter:filterFunc})}if(a){const r=await m(t,{readContents:false,hidden:true});const a=await m(i,{readContents:false,hidden:true});for(const o of a){if(o.startsWith(".git"))return;if(r.indexOf(o)===-1){const r=n.join(i,o);e.debug(`Found an orphaned file in the target repo - ${r}`);if(s.exclude!==undefined&&s.exclude.includes(n.join(t,o))){e.debug(`Excluding file ${o}`)}else{e.debug(`Removing file ${o}`);await u.remove(r)}}}}}async function remove(t){e.debug(`RM: ${t}`);return u.remove(t)}function arrayEquals(e,t){return Array.isArray(e)&&Array.isArray(t)&&e.length===t.length&&e.every(((e,i)=>e===t[i]))}const{GITHUB_TOKEN:w,GITHUB_SERVER_URL:b,IS_INSTALLATION_TOKEN:y,IS_FINE_GRAINED:I,GIT_USERNAME:R,GIT_EMAIL:E,TMP_DIR:$,COMMIT_BODY:C,COMMIT_PREFIX:P,GITHUB_REPOSITORY:T,OVERWRITE_EXISTING_PR:x,SKIP_PR:S,PR_BODY:k,BRANCH_PREFIX:O,FORK:A}=g;class Git{constructor(){const t=s.GitHub.plugin(a.throttling);const i=(0,s.getOctokitOptions)(w,{baseUrl:process.env.GITHUB_API_URL||"https://api.github.com",throttle:{onRateLimit:t=>{e.debug(`Hit GitHub API rate limit, retrying after ${t}s`);return true},onSecondaryRateLimit:t=>{e.debug(`Hit secondary GitHub API rate limit, retrying after ${t}s`);return true}}});const r=new t(i);this.github=r.rest}async initRepo(e){this.existingPr=undefined;this.prBranch=undefined;this.baseBranch=undefined;this.repo=e;this.workingDir=n.join($,e.uniqueName);this.gitUrl=`https://${y?"x-access-token:":""}${I?"oauth:":""}${w}@${e.fullName}.git`;await this.clone();await this.setIdentity();await this.getBaseBranch();await this.getLastCommitSha();if(A){const e=new URL(b);e.username=w;e.pathname=`${A}/${this.repo.name}.git`;await this.createFork();await this.createRemote(e.toString())}}async createFork(){e.debug(`Creating fork with OWNER: ${this.repo.user} and REPO: ${this.repo.name}`);await this.github.repos.createFork({owner:this.repo.user,repo:this.repo.name})}async createRemote(e){return execCmd(`git remote add fork ${e}`,this.workingDir)}async clone(){e.debug(`Cloning ${this.repo.fullName} into ${this.workingDir}`);return execCmd(`git clone --depth 1 ${this.repo.branch!=="default"?'--branch "'+this.repo.branch+'"':""} ${this.gitUrl} ${this.workingDir}`)}async setIdentity(){let t=R;let i=E;if(i===undefined){if(!y){const{data:e}=await this.github.users.getAuthenticated();i=e.email;t=e.login}}e.debug(`Setting git user to email: ${i}, username: ${t}`);return execCmd(`git config --local user.name "${t}" && git config --local user.email "${i}"`,this.workingDir)}async getBaseBranch(){this.baseBranch=await execCmd(`git rev-parse --abbrev-ref HEAD`,this.workingDir)}async createPrBranch(){const t=O.replace("SOURCE_REPO_NAME",T.split("/")[1]);let i=n.join(t,this.repo.branch).replace(/\\/g,"/").replace(/\/\./g,"/");if(x===false){i+=`-${Math.round((new Date).getTime()/1e3)}`}e.debug(`Creating PR Branch ${i}`);await execCmd(`git checkout -b "${i}"`,this.workingDir);this.prBranch=i}async add(e){return execCmd(`git add -f "${e}"`,this.workingDir)}isOneCommitPush(){return r.context.eventName==="push"&&r.context.payload.commits.length===1}originalCommitMessage(){return r.context.payload.commits[0].message}parseGitDiffOutput(e){return`\n${e}`.split("\ndiff --git").slice(1).reduce(((e,t)=>{const i=t.split("\n");const r=i.findIndex((e=>e.startsWith("+++")));if(r===-1)return e;const s=i.slice(r+1).join("\n").trim();let a="";if(i[r].startsWith("+++ b/")){a=i[r].slice(6)}else{a=i[r-1].slice(6)}return{...e,[a]:s}}),{})}async getChangesFromLastCommit(e){if(this.lastCommitChanges===undefined){const e=await this.github.repos.compareCommits({mediaType:{format:"diff"},owner:r.context.payload.repository.owner.name,repo:r.context.payload.repository.name,base:r.context.payload.before,head:r.context.payload.after});this.lastCommitChanges=this.parseGitDiffOutput(e.data)}if(e.endsWith("/")){return Object.keys(this.lastCommitChanges).filter((t=>t.startsWith(e))).reduce(((e,t)=>[...e,this.lastCommitChanges[t]]),[])}else{return this.lastCommitChanges[e]===undefined?[]:[this.lastCommitChanges[e]]}}async getLastCommitSha(){this.lastCommitSha=await execCmd(`git rev-parse HEAD`,this.workingDir)}async changes(e){const t=await execCmd(`git diff HEAD ${e}`,this.workingDir);return Object.values(this.parseGitDiffOutput(t))}async hasChanges(){const e=await execCmd(`git status --porcelain`,this.workingDir);return(0,i.parse)(e).length!==0}async commit(e){let t=e!==undefined?e:`${P} synced file(s) with ${T}`;if(C){t+=`\n\n${C}`}return execCmd(`git commit -m '${t.replace(/'/g,"'\\''")}'`,this.workingDir)}async getTreeId(t){e.debug(`Getting treeId for commit ${t}`);const i=(await execCmd(`git cat-file -p ${t}`,this.workingDir)).split("\n");const r=i.slice(0,i.findIndex((e=>e==="")));const s=r.find((e=>e.startsWith("tree"))).replace("tree ","");return s}async getTreeDiff(e,t){const i=await execCmd(`git diff-tree ${e} ${t} -r`,this.workingDir);const r=[];for(const e of i.split("\n")){const t=e.replace(/^:/,"").replace("\t"," ").split(" ");const[i,s,a,n,o,u]=t;r.push({newMode:i,previousMode:s,newBlob:a,previousBlob:n,change:o,path:u})}return r}async uploadGitHubBlob(t){e.debug(`Uploading GitHub Blob for blob ${t}`);const i=await execCmd(`git cat-file -p ${t}`,this.workingDir,false);return this.github.git.createBlob({owner:this.repo.user,repo:this.repo.name,content:Buffer.from(i).toString("base64"),encoding:"base64"})}async getCommitsToPush(){const e=await execCmd(`git log --format=%H --reverse ${S===false?``:`origin/`}${this.baseBranch}..HEAD`,this.workingDir);const t=e.split("\n");return t}async getCommitMessage(e){return await execCmd(`git log -1 --format=%B ${e}`,this.workingDir)}async createGithubVerifiedCommits(){e.debug(`Creating Commits using GitHub API`);const t=await this.getCommitsToPush();if(S===false){try{await this.github.git.createRef({owner:this.repo.user,repo:this.repo.name,sha:this.lastCommitSha,ref:"refs/heads/"+this.prBranch});e.debug(`Created new branch ${this.prBranch}`)}catch(e){if(e.message!=="Reference already exists")throw e}}for(const e of t){await this.createGithubCommit(e)}e.debug(`Updating branch ${S===false?this.prBranch:this.baseBranch} ref`);await this.github.git.updateRef({owner:this.repo.user,repo:this.repo.name,ref:`heads/${S===false?this.prBranch:this.baseBranch}`,sha:this.lastCommitSha,force:true});e.debug(`Commit using GitHub API completed`)}async status(){return execCmd(`git status`,this.workingDir)}async push(){if(A){return execCmd(`git push -u fork ${this.prBranch} --force`,this.workingDir)}if(y){return await this.createGithubVerifiedCommits()}return execCmd(`git push ${this.gitUrl} --force`,this.workingDir)}async findExistingPr(){const{data:e}=await this.github.pulls.list({owner:this.repo.user,repo:this.repo.name,state:"open",head:`${A?A:this.repo.user}:${this.prBranch}`});this.existingPr=e[0];return this.existingPr}async setPrWarning(){await this.github.pulls.update({owner:this.repo.user,repo:this.repo.name,pull_number:this.existingPr.number,body:dedent(`\n\t\t\t\t⚠️ This PR is being automatically resynced ⚠️\n\n\t\t\t\t${this.existingPr.body}\n\t\t\t`)})}async removePrWarning(){await this.github.pulls.update({owner:this.repo.user,repo:this.repo.name,pull_number:this.existingPr.number,body:this.existingPr.body.replace("⚠️ This PR is being automatically resynced ⚠️","")})}async createOrUpdatePr(t,i){const r=dedent(`\n\t\t\tsynced local file(s) with [${T}](${b}/${T}).\n\n\t\t\t${k}\n\n\t\t\t${t}\n\n\t\t\t---\n\n\t\t\tThis PR was created automatically by the [repo-file-sync-action](https://github.com/BetaHuhn/repo-file-sync-action) workflow run [#${process.env.GITHUB_RUN_ID||0}](${b}/${T}/actions/runs/${process.env.GITHUB_RUN_ID||0})\n\t\t`);if(this.existingPr){e.info(`Overwriting existing PR`);const{data:t}=await this.github.pulls.update({owner:this.repo.user,repo:this.repo.name,title:`${P} synced file(s) with ${T}`,pull_number:this.existingPr.number,body:r});return t}e.info(`Creating new PR`);const{data:s}=await this.github.pulls.create({owner:this.repo.user,repo:this.repo.name,title:i===undefined?`${P} synced file(s) with ${T}`:i,body:r,head:`${A?A:this.repo.user}:${this.prBranch}`,base:this.baseBranch});this.existingPr=s;return s}async addPrLabels(e){await this.github.issues.addLabels({owner:this.repo.user,repo:this.repo.name,issue_number:this.existingPr.number,labels:e})}async addPrAssignees(e){await this.github.issues.addAssignees({owner:this.repo.user,repo:this.repo.name,issue_number:this.existingPr.number,assignees:e})}async addPrReviewers(e){await this.github.pulls.requestReviewers({owner:this.repo.user,repo:this.repo.name,pull_number:this.existingPr.number,reviewers:e})}async addPrTeamReviewers(e){await this.github.pulls.requestReviewers({owner:this.repo.user,repo:this.repo.name,pull_number:this.existingPr.number,team_reviewers:e})}async createGithubCommit(t){const[i,r,s]=await Promise.all([this.getTreeId(`${t}`),this.getTreeId(`${t}~1`),this.getCommitMessage(t)]);const a=await this.getTreeDiff(i,r);e.debug(`Uploading the blobs to GitHub`);const n=a.filter((e=>e.newMode!=="000000"));await Promise.all(n.map((e=>this.uploadGitHubBlob(e.newBlob))));e.debug(`Creating a GitHub tree`);const o=a.map((e=>{if(e.newMode==="000000"){e.newMode=e.previousMode;e.newBlob=null}const t={path:e.path,mode:e.newMode,type:"blob",sha:e.newBlob};return t}));let u;try{const e=await this.github.git.createTree({owner:this.repo.user,repo:this.repo.name,tree:o,base_tree:r});u=e.data.sha}catch(e){e.message=`Cannot create a new GitHub Tree: ${e.message}`;throw e}e.debug(`Creating a commit for the GitHub tree`);const c=await this.github.git.createCommit({owner:this.repo.user,repo:this.repo.name,message:s,parents:[this.lastCommitSha],tree:u});this.lastCommitSha=c.data.sha}}const{COMMIT_EACH_FILE:N,COMMIT_PREFIX:M,PR_LABELS:B,ASSIGNEES:G,DRY_RUN:v,TMP_DIR:D,SKIP_CLEANUP:L,OVERWRITE_EXISTING_PR:H,SKIP_PR:U,ORIGINAL_MESSAGE:q,COMMIT_AS_PR_TITLE:F,FORK:W,REVIEWERS:j,TEAM_REVIEWERS:K}=g;async function run(){const i=new Git;const r=await parseConfig();const s=[];await forEach(r,(async r=>{e.info(`Repository Info`);e.info(`Slug\t\t: ${r.repo.name}`);e.info(`Owner\t\t: ${r.repo.user}`);e.info(`Https Url\t: https://${r.repo.fullName}`);e.info(`Branch\t\t: ${r.repo.branch}`);e.info("\t");try{await i.initRepo(r.repo);let a;if(U===false){await i.createPrBranch();a=H?await i.findExistingPr():undefined;if(a&&v===false){e.info(`Found existing PR ${a.number}`);await i.setPrWarning()}}e.info(`Locally syncing file(s) between source and target repository`);const n=[];await forEach(r.files,(async r=>{const s=t.existsSync(r.source);if(s===false)return e.warning(`Source ${r.source} not found`);const a=`${i.workingDir}/${r.dest}`;const o=t.existsSync(a);if(o===true&&r.replace===false)return e.warning(`File(s) already exist(s) in destination and 'replace' option is set to false`);const u=await pathIsDirectory(r.source);const c=u?`${addTrailingSlash(r.source)}`:r.source;const l=u?`${addTrailingSlash(a)}`:a;if(u)e.info(`Source is directory`);await copy(c,l,u,r);await i.add(r.dest);if(N===true){const t=await i.hasChanges();if(t===false)return e.debug("File(s) already up to date");e.debug(`Creating commit for file(s) ${r.dest}`);const s=u?"directory":"";const a=u?"and copied all sub files/folders":"";const c=q&&i.isOneCommitPush()&&arrayEquals(await i.getChangesFromLastCommit(r.source),await i.changes(r.dest));const l={true:{commit:c?i.originalCommitMessage():`${M} synced local '${r.dest}' with remote '${r.source}'`,pr:`synced local ${s} <code>${r.dest}</code> with remote ${s} <code>${r.source}</code>`},false:{commit:c?i.originalCommitMessage():`${M} created local '${r.dest}' from remote '${r.source}'`,pr:`created local ${s} <code>${r.dest}</code> ${a} from remote ${s} <code>${r.source}</code>`}};await i.commit(l[o].commit);n.push({dest:r.dest,source:r.source,message:l[o].pr,useOriginalMessage:c,commitMessage:l[o].commit})}}));e.setOutput("modified_files",n.map((e=>e.dest)));if(v){e.warning("Dry run, no changes will be pushed");e.debug("Git Status:");e.debug(await i.status());return}const o=await i.hasChanges();if(o===false&&n.length<1){e.info("File(s) already up to date");if(a)await i.removePrWarning();return}if(o===true){e.debug(`Creating commit for remaining files`);let t=q&&i.isOneCommitPush();if(t){await forEach(r.files,(async e=>{t=t&&arrayEquals(await i.getChangesFromLastCommit(e.source),await i.changes(e.dest))}))}const s=t?i.originalCommitMessage():undefined;await i.commit(s);n.push({dest:i.workingDir,useOriginalMessage:t,commitMessage:s})}e.info(`Pushing changes to target repository`);await i.push();if(U===false){const t=dedent(`\n\t\t\t\t\t<details>\n\t\t\t\t\t<summary>Changed files</summary>\n\t\t\t\t\t<ul>\n\t\t\t\t\t${n.map((e=>`<li>${e.message}</li>`)).join("")}\n\t\t\t\t\t</ul>\n\t\t\t\t\t</details>\n\t\t\t\t`);const r=F&&n.length===1&&n[0].useOriginalMessage;const a=await i.createOrUpdatePr(N?t:"",r?n[0].commitMessage.split("\n",1)[0].trim():undefined);e.notice(`Pull Request #${a.number} created/updated: ${a.html_url}`);s.push(a.html_url);if(B!==undefined&&B.length>0&&!W){e.info(`Adding label(s) "${B.join(", ")}" to PR`);await i.addPrLabels(B)}if(G!==undefined&&G.length>0&&!W){e.info(`Adding assignee(s) "${G.join(", ")}" to PR`);await i.addPrAssignees(G)}if(j!==undefined&&j.length>0&&!W){e.info(`Adding reviewer(s) "${j.join(", ")}" to PR`);await i.addPrReviewers(j)}if(K!==undefined&&K.length>0&&!W){e.info(`Adding team reviewer(s) "${K.join(", ")}" to PR`);await i.addPrTeamReviewers(K)}}e.info("\t")}catch(t){e.setFailed(t.message);e.debug(t)}}));if(s){e.setOutput("pull_request_urls",s)}if(L===true){e.info("Skipping cleanup");return}await remove(D);e.info("Cleanup complete")}run().catch((t=>{e.setFailed(t.message);e.debug(t)}))})();